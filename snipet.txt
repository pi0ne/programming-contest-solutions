{
	"cout_yes_no":{
		"prefix": "yesno",
		"body":[
			"if($1) cout<<\"Yes\"<<endl;",
  		"else cout<<\"No\"<<endl;"
		]
	},
	"priority_queue_asc":{
		"prefix": "pqasc",
		"body":[
			"priority_queue<$1, vector<$1>, greater<$1>>"
		]
	},
	"add_mul":{
		"prefix": "addmul",
		"body":[
			"void add(ll& a, ll b){",
			"\ta = (a+b) % MOD;",
			"}",
			"",
			"void mul(ll& a, ll b){",
			"\ta = (a*b) % MOD;",
			"}"
		]
	},
	"cout_fail":{
		"prefix": "fail",
		"body":[
			"void fail(){",
			"\tcout << 0 << endl;",
			"\texit(0);",
			"}"
		]
	},
	"memset-inf":{
		"prefix": "memsetinf",
		"body": [
			"memset($1,0x3f,sizeof($1));"
		]
	},
	"loop-for":{
		"prefix": "loopf",
		"body":[
			"for($1){",
			"\t",
			"}"
		]
	},
	"rsort":{
		"prefix": "rsort",
		"body": [
			"sort($1.rbegin(),$1.rend());"
		]
	},
	"cout-space":{
		"prefix": "sppp",
		"body":[
			"<<\" \"<<"
		]
	},
	"coutd":{
		"prefix": "coutd",
		"body": "cout<<std::setprecision(10)<<$1<<endl;"
	},
	"replace-all":{
		"prefix": "replace-all",
		"body":[
			"regex_replace($1, regex(\"$2\"), \"$3\");"
		]
	},
	"eratosthenes":{
		"prefix": "eratos",
		"body":[
			"const ll maxn_eratosthenes = 1000005;",
			"bool _is_prime[maxn_eratosthenes];",
			"vector<ll> P;",
			"vector<ll> min_prime_can_divide_i;",
			"",
			"void eratosthenes(const ll N)",
			"{",
			"\tP.clear();",
			"\tmin_prime_can_divide_i = vll(maxn_eratosthenes+1, 1);",
			"\tfor (ll i = 0; i <= N; i++) {",
			"\t\t_is_prime[i] = true;",
			"\t}",
			"\t_is_prime[0]=_is_prime[1]=false;",
			"\tfor (ll i = 2; i <= N; i++) {",
			"\t\tif (_is_prime[i]) {",
			"\t\t\tfor (ll j = 2 * i; j <= N; j += i) {",
			"\t\t\t\t_is_prime[j] = false;",
			"\t\t\t\tmin_prime_can_divide_i[j] = i;",
			"\t\t\t}",
			"\t\t\tP.emplace_back(i);",
			"\t\t\tmin_prime_can_divide_i[i] = i;",
			"\t\t}",
			"\t}",
			"}"
		]
	},
	"union-find":{
		"prefix": "uf",
		"body":[
			"class UnionFind{",
			"private:",
			"\tvector<ll> Parent; ",
			" public:",
			"\tUnionFind(ll N){",
			"\t\tParent = vector<ll>(N, -1);",
			"\t}",
			"\t",
			"\tll root(ll A){",
			"\t\tif(Parent[A] < 0) return A;",
			"\t\treturn Parent[A] = root(Parent[A]);",
			"\t}",
			"\t",
			"\tll size(ll A){",
			"\t\treturn -Parent[root(A)]; ",
			"\t}",
			"\t",
			"\tbool connect(ll A, ll B){",
			"\t\tA = root(A);",
			"\t\tB = root(B);",
			"\t\tif(A == B){",
			"\t\t\treturn false;",
			"\t\t}",
			"\t\tif(size(A) < size(B)) swap(A, B);",
			"\t\tParent[A] += Parent[B];",
			"\t\tParent[B] = A;",
			"\t\treturn true;",
			"\t}",
			"\t",
			"\tbool isSame(ll A, ll B){",
			"\t\treturn root(A) == root(B);",
			"\t}",
			"};"
		]
	},
	"binary-indexed-tree":{
		"prefix": "BIT",
		"body":[
			"template<typename T>",
			"struct BIT {",
			"\tint n;",
			"\tvector<T> d;",
			"\tBIT(int n=0):n(n),d(n+1) {}",
			"\tvoid add(int i, T x=1) {",
			"\t\tfor (; i <= n; i += i&-i) {",
			"\t\t\td[i] += x;",
			"\t\t}",
			"\t}",
			"\tT sum(int i) {",
			"\t\tT x = 0;",
			"\t\tfor (; i; i -= i&-i) {",
			"\t\t\tx += d[i];",
			"\t\t}",
			"\t\treturn x;",
			"\t}",
			"\t// 閉区間[l,r]の累積和を求める",
			"\tT sum(int l, int r) {",
			"\t\treturn sum(r) - sum(l-1);",
			"\t}",
			"};"
		]
	},
	"combination":{
		"prefix": "comb",
		"body":[
			"ll modpow(ll a, ll n) {",
			"\tll res = 1;",
			"\twhile (n > 0) {",
			"\t\tif (n & 1) res = res * a % MOD;",
			"\t\t(a *= a) %= MOD;",
			"\t\tn >>= 1;",
			"\t}",
			"\treturn res;",
			"}",
			"",
			"const ll maxf = 10000000;",
			"ll fact[maxf+5];",
			"ll ifact[maxf+5];",
			"",
			"void fact_init(){",
			"\tfact[0] = 1;",
			"\tfor(ll i=1; i<=maxf; i++) fact[i] = (fact[i-1] * i) % MOD;",
			"\tifact[maxf]=modpow(fact[maxf],MOD-2);",
			"\tfor(ll i=maxf; i>=1; i--) ifact[i-1] = (ifact[i] * i) % MOD;",
			"}",
			"",
			"ll comb(ll n, ll r){",
			"\tif(n<r || n<0 || r<0) return 0;",
			"\tif(fact[0] == 0) fact_init();",
			"\treturn ((fact[n] * ifact[n-r]) % MOD * ifact[r]) % MOD;",
			"}",
			"",
			"ll naive_comb(ll n, ll r){",
			"\tll res = 1;",
			"\tfor (ll i = n; i > n - r; i--) res = res * i % MOD;",
			"\tfor (ll i = 1; i <= r; i++) res = (res * modpow(i, MOD-2)) % MOD;",
			"\treturn res;",
			"}"
		]
	},
	"mod-pow":{
		"prefix": "mod-pow",
		"body": [
			"ll modpow(ll a, ll n) {",
			"\tll res = 1;",
			"\twhile (n > 0) {",
			"\t\tif (n & 1) res = res * a % MOD;",
			"\t\t(a *= a) %= MOD;",
			"\t\tn >>= 1;",
			"\t}",
			"\treturn res;",
			"}"
		]
	},
	"math-tools":{
		"prefix": "mathtools",
		"body":[
			"ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }",
			"ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }",
			"",
			"ll ngcd(vector<ll>& a) {",
			"\tll res = a[0];",
			"\tfor(ll i=1; i<a.size() && res!=1; i++) res = gcd(a[i], res);",
			"\treturn res;",
			"}",
			"ll nlcm(vector<ll>& a){",
			"\tll res = a[0];",
			"\tfor(ll i=1; i<a.size(); i++) res = lcm(a[i], res);",
			"\treturn res;",
			"}",
			"bool is_prime(ll n) {",
			"\tif(n < 2) return false;",
			"\tfor (ll i = 2; i * i <= n; i++) if (n % i == 0) return false;",
			"\treturn true;",
			"}",
			"ll digsum(ll n) {",
			"\tll res=0;",
			"\twhile(n) res += n%10, n /= 10;",
			"\treturn res;",
			"}",
			"ll digcnt(ll n){",
			"\tll res=0;",
			"\twhile(n) res++, n /= 10;",
			"\treturn res;",
			"}",
			"vector<ll> divisor(ll n) {",
			"\tvector<ll> res;",
			"\tfor (ll i = 1; i * i <= n; i++) {",
			"\t\tif (n % i == 0) {",
			"\t\t\tres.push_back(i);",
			"\t\t\tif (i != n / i) res.push_back(n / i);",
			"\t\t}",
			"\t}",
			"\tsort(res.begin(), res.end());",
			"\treturn res;",
			"}",
			"map<ll, ll> prime_factor(ll n) {",
			"\tmap<ll, ll> res;",
			"\tfor (ll i = 2; i * i <= n; i++) {",
			"\t\twhile (n % i == 0) ++res[i], n /= i;",
			"\t}",
			"\tif (n != 1) res[n] = 1;",
			"\treturn res;",
			"}"
		]	
	},
	"graph-tools":{
		"prefix": "graf",
		"body":[
			"const ll dy[] = {0, 1, 0, -1, -1, 1, 1, -1};",
			"const ll dx[] = {1, 0, -1, 0, 1, 1, -1, -1};",
			"",
			"inline bool inside(ll y, ll x, ll H, ll W) {",
			"\t\treturn (y >= 0 && x >= 0 && y < H && x < W);",
			"}"
		]
	},
	"bit-count":{
		"prefix":"bit-count",
		"body":[
			"ll bitcount(ll x){",
			"\tif(x==0) return 0;",
			"\treturn bitcount(x>>1)+(x&1);",
			"}"
		]
	},
	"bellman-ford":{
		"prefix":"bellman-ford",
		"body":[
			"const ll maxn_bellmanford=2505;",
			"vector<vll> G(maxn_bellmanford);",
			"bool reachableFrom1[maxn_bellmanford];",
			"void dfs(ll v){",
			"\tif(reachableFrom1[v]) return;",
			"\treachableFrom1[v]=true;",
			"\tfor(auto nv: G[v]){",
			"\t\tdfs(nv);",
			"\t}",
			"}",
			"",
			"vector<vll> rG(maxn_bellmanford);",
			"bool reachableToN[maxn_bellmanford];",
			"void rdfs(ll v){",
			"\tif(reachableToN[v]) return;",
			"\treachableToN[v]=true;",
			"\tfor(auto nv: rG[v]){",
			"\t\trdfs(nv);",
			"\t}",
			"}",
			"",
			"ll n,m;",
			"vector<tuple<ll,ll,ll>> es;",
			"ll dist[maxn_bellmanford];",
			"bool ok[maxn_bellmanford];",
			"",
			"bool bellmanford(ll s){",
			"\tfill(dist,dist+n,INF);",
			"\tdist[s]=0;",
			"\tbool update=true;",
			"\tll cnt=0;",
			"\twhile(update){",
			"\t\tupdate=false;",
			"\t\tfor(auto e: es){",
			"\t\t\tll a,b,c;",
			"\t\t\ttie(a,b,c)=e;",
			"\t\t\tif(!ok[a]||!ok[b]) continue;",
			"\t\t\tif(chmin(dist[b],dist[a]+c)) update=true;",
			"\t\t}",
			"\t\tif(cnt>=n){",
			"\t\t\treturn true; // has negative loop",
			"\t\t}",
			"\t\tcnt++;",
			"\t}",
			"\treturn false;",
			"}"
		]
	},
	"dijkstra":{
		"prefix": "dijkstra",
		"body":[
			"ll n,m;",
			"const ll maxn_dijkstra=200005;",
			"vector<pll> G[maxn_dijkstra];",
			"ll dist[maxn_dijkstra];",
			"",
			"void dijkstra(ll s){",
			"\tfill(dist,dist+n,LINF);",
			"\tdist[s]=0;",
			"\tpriority_queue<pll, vector<pll>, greater<pll>> q;",
			"\tq.emplace(0,s);",
			"\twhile(!q.empty()){",
			"\t\tpll v=q.top(); q.pop();",
			"\t\tif(dist[v.second]<v.first) continue;",
			"\t\tfor(auto nv: G[v.second]){",
			"\t\t\tif(dist[nv.first]>dist[v.second]+nv.second){",
			"\t\t\t\tdist[nv.first]=dist[v.second]+nv.second;",
			"\t\t\t\tq.emplace(dist[nv.first],nv.first);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"}"
		]
	},
	"warshall-floyd":{
		"prefix": "warshall-floyd",
		"body": [
			"const ll maxn_warshall_floyd=505;",
			"ll dist[maxn_warshall_floyd][maxn_warshall_floyd];",
			"ll n;",
			"void warshallfloyd(){",
			"\tfor(ll k = 0; k < n; k++)",
			"\t\tfor(ll i = 0; i < n; i++)",
			"\t\t\tfor(ll j = 0; j < n; j++)",
			"\t\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);",
			"}"
		]
	},
	"longest-increasing-subsequence":{
		"prefix": "lis",
		"body": [
			"template<class T> ll lis(vector<T> a, bool is_strong=true){",
			"\tconst T INF = 1<<30;",
			"\tll n = (ll) a.size();",
			"\tvector<T> dp(n, INF);",
			"\trep(i,n){",
			"\t\tif(is_strong) *lower_bound(all(dp), a[i]) = a[i];",
			"\t\telse *upper_bound(all(dp), a[i]) = a[i];",
			"\t}",
			"\treturn lower_bound(all(dp), INF) - dp.begin();",
			"}"
		]
	},
	"split":{
		"prefix": "split",
		"body":[
			"template<class T> std::vector<std::string> split(const std::string& s, const T& separator, bool ignore_empty = 0, bool split_empty = 0) {",
			"\tstruct {",
			"\t\tauto len(const std::string&\t\t\t\t\t\t s) { return s.length(); }",
			"\t\tauto len(const std::string::value_type* p) { return p ? std::char_traits<std::string::value_type>::length(p) : 0; }",
			"\t\tauto len(const std::string::value_type\tc) { return c == std::string::value_type() ? 0 : 1; /*return 1;*/ }",
			"\t} util;",
			"\t",
			"\tif (s.empty()) { /// empty string ///",
			"\t\tif (!split_empty || util.len(separator)) return {""};",
			"\t\treturn {};",
			"\t}",
			"\t",
			"\tauto v = std::vector<std::string>();",
			"\tauto n = static_cast<std::string::size_type>(util.len(separator));",
			"\tif (n == 0) {",
			"\t\tif (!split_empty) return {s};",
			"\t\tfor (auto&& c : s) v.emplace_back(1, c);",
			"\t\treturn v;",
			"\t}",
			"\t",
			"\tauto p = std::string::size_type(0);",
			"\twhile (1) {",
			"\t\tauto pos = s.find(separator, p);",
			"\t\tif (pos == std::string::npos) {",
			"\t\t\tif (ignore_empty && p - n + 1 == s.size()) break;",
			"\t\t\tv.emplace_back(s.begin() + p, s.end());",
			"\t\t\tbreak;",
			"\t\t}",
			"\t\tif (!ignore_empty || p != pos)",
			"\t\t\tv.emplace_back(s.begin() + p, s.begin() + pos);",
			"\t\tp = pos + n;",
			"\t}",
			"\treturn v;",
			"}"
		]
	},
	"minus1":{
		"prefix": "minus1",
		"body":[
			"string minus1(string s){",
			"\tll n=s.size();",
			"\treverse(all(s));",
			"\trep(i,n){",
			"\t\tif(s[i]!='0'){",
			"\t\t\ts[i]--;",
			"\t\t\tbreak;",
			"\t\t}",
			"\t\ts[i]='9';",
			"\t}",
			"\tif(s[n-1]=='0') s.resize(n-1);",
			"\treverse(all(s));",
			"\treturn s;",
			"}"
		]
	},
	"to_binary":{
		"prefix": "tobinary",
		"body":[
			"string to_binary(ll n, int digit = 0) {",
			"\tstring res = \"\";",
			"\twhile (n) {",
			"\t\tif (n & 1) res = \"1\" + res;",
			"\t\telse res = \"0\" + res;",
			"\t\tn >>= 1;",
			"\t}",
			"\tif (0 < digit) {",
			"\t\tint n = digit - res.length();",
			"\t\trep(i, n) res = \"0\" + res;",
			"\t}",
			"\treturn res;",
			"}"
		]
	},
	"kika":{
		"prefix": "kika",
		"body":[
			"/* 幾何ライブラリ */",
			"using DD = double;",
			"const DD EPS = 1e-10;\t\t\t\t// to be set appropriately",
			"DD torad(int deg) {return (DD)(deg) * PI / 180;}",
			"DD todeg(DD ang) {return ang * 180 / PI;}",
			" ",
			"/* Point */",
			"struct Point {",
			"\t\tDD x, y;",
			"\t\tPoint(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}",
			"\t\tfriend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}",
			"};",
			"inline Point operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}",
			"inline Point operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}",
			"inline Point operator * (const Point &p, DD a) {return Point(p.x * a, p.y * a);}",
			"inline Point operator * (DD a, const Point &p) {return Point(a * p.x, a * p.y);}",
			"inline Point operator * (const Point &p, const Point &q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}",
			"inline Point operator / (const Point &p, DD a) {return Point(p.x / a, p.y / a);}",
			"inline Point conj(const Point &p) {return Point(p.x, -p.y);}",
			"inline Point rot(const Point &p, DD ang) {return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}",
			"inline Point rot90(const Point &p) {return Point(-p.y, p.x);}",
			"inline DD cross(const Point &p, const Point &q) {return p.x * q.y - p.y * q.x;}",
			"inline DD dot(const Point &p, const Point &q) {return p.x * q.x + p.y * q.y;}",
			"inline DD norm(const Point &p) {return dot(p, p);}",
			"inline DD abs(const Point &p) {return sqrt(dot(p, p));}",
			"inline DD amp(const Point &p) {DD res = atan2(p.y, p.x); if (res < 0) res += PI*2; return res;}",
			"inline bool eq(const Point &p, const Point &q) {return abs(p - q) < EPS;}",
			"inline bool operator < (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y);}",
			"inline bool operator > (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y);}",
			"inline Point operator / (const Point &p, const Point &q) {return p * conj(q) / norm(q);}",
			" ",
			"/* Line */",
			"struct Line : vector<Point> {",
			"\t\tLine(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {",
			"\t\t\t\tthis->push_back(a);",
			"\t\t\t\tthis->push_back(b);",
			"\t\t}",
			"\t\tfriend ostream& operator << (ostream &s, const Line &l) {return s << '{' << l[0] << \", \" << l[1] << '}';}",
			"};",
			" ",
			"// 1：a-bから見てcは左側(反時計回り)、-1：a-bから見てcは右側(時計回り)、0：一直線上",
			"int simple_ccw(const Point &a, const Point &b, const Point &c) {",
			"\t\tif (cross(b-a, c-a) > EPS) return 1;",
			"\t\tif (cross(b-a, c-a) < -EPS) return -1;",
			"\t\treturn 0;",
			"}",
			" ",
			"// 円や直線の交点",
			"vector<Point> crosspoint(const Line &l, const Line &m) {",
			"\t\tvector<Point> res;",
			"\t\tDD d = cross(m[1] - m[0], l[1] - l[0]);",
			"\t\tif (abs(d) < EPS) return vector<Point>();",
			"\t\tres.push_back(l[0] + (l[1] - l[0]) * cross(m[1] - m[0], m[1] - l[0]) / d);",
			"\t\treturn res;",
			"}",
			" ",
			"// 外心",
			"Point gaisin(Point a, Point b, Point c) {",
			"\t\tLine ab((a+b)/2, (a+b)/2 + rot90(a-b));",
			"\t\tLine bc((b+c)/2, (b+c)/2 + rot90(b-c));",
			"\t\treturn crosspoint(ab, bc)[0];",
			"}",
			" ",
			"// 最小包含円",
			"double minimum_bounding_circle(vector<Point>& v){",
			"\tll n=v.size();",
			"\tvector<Point> cond; // 候補",
			"\trep(i,n) irep(j,i+1,n){",
			"\t\tcond.push_back((v[i]+v[j])/2);",
			"\t\tirep(k,j+1,n){",
			"\t\t\tif(simple_ccw(v[i],v[j],v[k])==0) continue;",
			"\t\t\tauto p=gaisin(v[i],v[j],v[k]);",
			"\t\t\tcond.push_back(p);",
			"\t\t}",
			"\t}",
			"\t",
			"\tdouble res=INF;",
			"\tfor(auto e: cond){",
			"\t\tdouble tmp=0;",
			"\t\trep(i,n) chmax(tmp,abs(e-v[i]));",
			"\t\tchmin(res,tmp);",
			"\t}",
			"\t",
			"\treturn res;",
			"}"
		]
	},
	"days":{
		"prefix": "days",
		"body":[
			"int DAYS[]={31,29,31,30,31,30,31,31,30,31,30,31};"
		]
	},
	"printd":{
		"prefix": "printd",
		"body":[
			"printf(\"%.15lf\\n\", $1);"
		]
	}
}